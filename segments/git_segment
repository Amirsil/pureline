#!/usr/bin/env bash

# git_segment

PL_SYMBOLS['git']=${PL_SYMBOLS[git]:-' '}

# -----------------------------------------------------------------------------
# segment content: git branch with indictors for status
# option variables;
#   PL_GIT_SHOW_STATUS
# shellcheck disable=SC2034
function _git_segment {
    local -n _content="${1:-}"
    local -n _hilite="${2:-false}"

    command -v git &> /dev/null  || return # exit early if no git

    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
    [[ -z ${branch}  ]] && return;  # return early if not a git branch

    _content="${PL_SYMBOLS[git]}${branch}"

    if ${PL_GIT_SHOW_STATUS:-true}; then
        local added=0
        local modified=0
        local staged=0
        local deleted=0
        local untracked=0
        local other=0
        local stashed=0
        local ahead=0
        local behind=0

        # Read through git status porcelain
        local state tracking
        while IFS= read -r line; do # clear IFS to retain trailing whitespace
            state=${line:0:2}
            case ${state} in
                \#\#)           # branch line contains ahead/behind info
                    tracking=${line#*[}; tracking=${tracking%]*}
                    [[ ${tracking} =~ (behind )([^,]*) ]] &&
                        behind=${BASH_REMATCH[0]/behind /}
                    [[ ${tracking} =~ (ahead )([^,]*) ]] &&
                        ahead=${BASH_REMATCH[0]/ahead /}
                    ;;
                \?\?)           # untracked
                    untracked=$((untracked+1))
                    ;;
                ?A)             # added but not staged
                    added=$((added+1))
                    ;;&
                ?D)             # deleted
                    deleted=$((deleted+1))
                    ;;&
                ?M|?R)          # modified/renamed but not staged
                    modified=$((modified+1))
                    ;;&
                M?|A?|D?|R?)    # changes staged to be commited
                    staged=$((staged+1))
                    ;;
                *)              # (C)opied and (U)pdated/unmerged states
                    other=$((other+1))
            esac
        done <<< "$(git status -b --porcelain 2> /dev/null)"

        while read -r line; do
            [[ -n ${line} ]] && stashed=$((stashed+1));
        done <<< "$(git stash list 2> /dev/null)"

        [[ $((added+modified+deleted+untracked+staged+other)) -ne 0 ]] &&
            _hilite=true

        [[ ${staged} -ne 0 ]] && _content="•${staged} ${_content}"
        [[ ${modified} -ne 0 ]] && _content="~${modified} ${_content}"
        [[ ${added} -ne 0 ]] && _content="+${added} ${_content}"
        [[ ${deleted} -ne 0 ]] && _content="-${deleted} ${_content}"
        [[ ${untracked} -ne 0 ]] && _content="?${untracked} ${_content}"

        [[ ${ahead} -ne 0 ]] && _content+=" ↑${ahead}"
        [[ ${behind} -ne 0 ]] && _content+=" ↓${behind}"
        [[ ${stashed} -ne 0 ]] && _content+=" §${stashed}"
    fi
}

