#!/bin/env bash

# git_segment

PL_SYMBOLS+=(
    # GUI Font Symbols      # Standard Symbols for tty
    [git_branch]=""        [tty_git_branch]="╬" 
    [git_untracked]="?"
    [git_stash]="§"
    [git_ahead]="↑"
    [git_behind]="↓"
    [git_modified]="~"
    [git_staged]="✔ "       [tty_git_staged]="•"
    [git_conflicts]="✘ "    [tty_git_conflicts]="*"
)

# -----------------------------------------------------------------------------
# append to prompt: git branch with indictors for;
#     number of; modified files, staged files and conflicts
# arg: $1 foreground color
# arg; $2 background color
# option variables;
#   PL_GIT_STASH: true/false
#   PL_GIT_AHEAD: true/false
#   PL_GIT_STAGED: true/false
#   PL_GIT_CONFLICTS: true/false
#   PL_GIT_MODIFIED: true/false
#   PL_GIT_UNTRACKED: true/false
function git_segment {
    local git_branch

    git_branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
    
    [[ -z $git_branch  ]] && return;  ## return early if not a git branch

    local bg_color="$1"
    local fg_color="$2"
    local content

    if $PL_GIT_STASH ; then
        local number_stash
        number_stash="$(git stash list 2>/dev/null | grep -F -v -c 'fatal:' | tr -d '[:space:]')"
        if [[ $number_stash -ne 0 ]]; then
            content+=" $(pl_symbol 'git_stash')$number_stash"
        fi
    fi

    if $PL_GIT_AHEAD ; then
        local number_behind_ahead
        number_behind_ahead="$(git rev-list --count --left-right '@{upstream}...HEAD' 2>/dev/null)"
        local number_ahead="${number_behind_ahead#*	}"
        local number_behind="${number_behind_ahead%	*}"
        if [[ $number_ahead -ne 0 || $number_behind -ne 0 ]]; then
            if [[ $number_ahead -ne 0 ]]; then
                content+=" $(pl_symbol 'git_ahead')$number_ahead"
            fi
            if [[ $number_behind -ne 0 ]]; then
                content+=" $(pl_symbol 'git_behind')$number_behind"
            fi
        fi
    fi

    if $PL_GIT_STAGED ; then
        local number_staged
        number_staged="$(git diff --staged --name-only --diff-filter=AM 2> /dev/null | wc -l | tr -d '[:space:]')"
        if [[ $number_staged -ne 0 ]]; then
            content+=" $(pl_symbol 'git_staged')$number_staged"
        fi
    fi

    if $PL_GIT_CONFLICTS ; then
        local number_conflicts
        number_conflicts="$(git diff --name-only --diff-filter=U 2> /dev/null | wc -l | tr -d '[:space:]')"
        if [[ $number_conflicts -ne 0 ]]; then
            content+=" $(pl_symbol 'git_conflicts')$number_conflicts"
        fi
    fi

    if $PL_GIT_MODIFIED ; then
        local number_modified
        number_modified="$(git diff --name-only --diff-filter=M 2> /dev/null | wc -l | tr -d '[:space:]')"
        if [[ $number_modified -ne 0 ]]; then
            content+=" $(pl_symbol 'git_modified')$number_modified"
        fi
    fi

    if $PL_GIT_UNTRACKED ; then
        local number_untracked
        number_untracked="$(git ls-files --other --exclude-standard 2> /dev/null | wc -l | tr -d '[:space:]')"
        if [[ $number_untracked -ne 0 ]]; then
            content+=" $(pl_symbol 'git_untracked')$number_untracked"
        fi
    fi

    if [[ -n "$(git status --porcelain 2> /dev/null)" ]]; then
        [[ -n "$PL_GIT_DIRTY_FG" ]] && fg_color="$PL_GIT_DIRTY_FG"
        [[ -n "$PL_GIT_DIRTY_BG" ]] && bg_color="$PL_GIT_DIRTY_BG"
    fi

    content+=" $(pl_symbol 'git_branch') $git_branch"

    PS1+="$(segment_end "$fg_color" "$bg_color")"
    PS1+="$(segment_content "$fg_color" "$bg_color" "$content ")"
    # shellcheck disable=SC2034
    __last_color="$bg_color"    # variable will be used when sourced
}

