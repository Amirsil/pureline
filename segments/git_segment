#!/usr/bin/env bash

# git_segment

PL_GIT_SYMBOL=' '

# -----------------------------------------------------------------------------
# append to prompt: git branch with indictors for;
#     number of; modified files, staged files and conflicts
# arg: $1 primary color
# arg: $2 secondary color
# arg: $3 primary hilite
# arg: $4 secondary hilite
# option variables;
#   PL_GIT_SHOW_STATUS
function git_segment {
    command -v git &> /dev/null  || return # exit early if no git

    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
    [[ -z ${branch}  ]] && return;  # return early if not a git branch

    local primary_color="$1"
    local secondary_color="$2"
    local primary_hilite="$3"
    local secondary_hilite="$4"
    local content
    content="${PL_GIT_SYMBOL}${branch}"

    if ${PL_GIT_SHOW_STATUS:-true}; then
        local added=0
        local modified=0
        local staged=0
        local deleted=0
        local untracked=0
        local other=0
        local stashed=0
        local ahead=0
        local behind=0

        # Read through git status porcelain
        local state tracking
        while IFS= read -r line; do # clear IFS to retain trailing whitespace
            state=${line:0:2}
            case ${state} in
                \#\#)           # branch line contains ahead/behind info
                    tracking=${line#*[}; tracking=${tracking%]*}
                    [[ ${tracking} =~ (behind )([^,]*) ]] &&
                        behind=${BASH_REMATCH[0]/behind /}
                    [[ ${tracking} =~ (ahead )([^,]*) ]] &&
                        ahead=${BASH_REMATCH[0]/ahead /}
                    ;;
                \?\?)           # untracked
                    untracked=$((untracked+1))
                    ;;
                ?A)             # added but not staged
                    added=$((added+1))
                    ;;&
                ?D)             # deleted
                    deleted=$((deleted+1))
                    ;;&
                ?M|?R)          # modified/renamed but not staged
                    modified=$((modified+1))
                    ;;&
                M?|A?|D?|R?)    # changes staged to be commited
                    staged=$((staged+1))
                    ;;
                *)              # (C)opied and (U)pdated/unmerged states
                    other=$((other+1))
            esac
        done <<< "$(git status -b --porcelain 2> /dev/null)"

        while read -r line; do
            [[ -n ${line} ]] && stashed=$((stashed+1));
        done <<< "$(git stash list 2> /dev/null)"

        if [[ $((added+modified+deleted+untracked+staged+other)) -ne 0 ]]; then
            primary_color="${primary_hilite:-${primary_color}}"
            secondary_color="${secondary_hilite:-${secondary_color}}"
        fi

        [[ ${staged} -ne 0 ]] && content="•${staged} ${content}"
        [[ ${modified} -ne 0 ]] && content="~${modified} ${content}"
        [[ ${added} -ne 0 ]] && content="+${added} ${content}"
        [[ ${deleted} -ne 0 ]] && content="-${deleted} ${content}"
        [[ ${untracked} -ne 0 ]] && content="?${untracked} ${content}"

        [[ ${ahead} -ne 0 ]] && content+=" ↑${ahead}"
        [[ ${behind} -ne 0 ]] && content+=" ↓${behind}"
        [[ ${stashed} -ne 0 ]] && content+=" §${stashed}"
    fi
    add_segment "${content}" "${primary_color}" "${secondary_color}"
}

