#!/bin/env bash

# git_segment

PL_SYMBOLS+=(
    # GUI Font Symbols      # Standard Symbols for tty
    [git]=""               [tty_git]="╬" 
)

# -----------------------------------------------------------------------------
# append to prompt: git branch with indictors for;
#     number of; modified files, staged files and conflicts
# arg: $1 foreground color
# arg; $2 background color
# option variables;
#   PL_GIT_SHOW_STATUS
#   PL_GIT_DIRTY_FG
#   PL_GIT_DIRTY_BG
function git_segment {
    command -v git &> /dev/null  || return # exit early if no git

    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
    bg_color="$1"
    fg_color="$2"
    
    [[ -z ${branch}  ]] && return;  # return early if not a git branch

    local added=0
    local modified=0
    local staged=0
    local deleted=0
    local untracked=0
    local stashed=0
    local ahead=0
    local behind=0
    local state

    # Read through git status porcelain
    local ifs=$IFS; IFS='' # change IFS to stop leading spaces being stripped
    while read -r line; do
        state=${line:0:2}
        case $state in
            *\#*)           # branch line contains ahead/behind info
                up=${line#*[}; up=${up%]*}
                if [[ ${up} != "${line}" ]] ; then
                    [[ $up =~ (behind )([^,]*) ]] && behind=${BASH_REMATCH[0]}
                    behind=${behind/behind /}
                    [[ $up =~ (ahead )([^,]*) ]] && ahead=${BASH_REMATCH[0]}
                    ahead=${ahead/ahead /}
                fi
                ;;
            ?A*)            # added but not staged
                added=$((added+1))
                ;;&
            ?M*|?R*)        # modified/renamed but not staged
                modified=$((modified+1))
                ;;&
            A*|M*|R*)       # changes staged to be comiited
                staged=$((staged+1))
                ;;&
            ?D*)            # deleted
                deleted=$((deleted+1))
                ;;&
            \?*)            # untracked
                untracked=$((untracked+1))
        esac
    done <<< "$(git status -b --porcelain 2> /dev/null)"
    IFS=$ifs    # change IFS back to stop breaking calling functions/loops

    stashed="$(git stash list 2>/dev/null | grep -F -v -c 'fatal:' | tr -d '[:space:]')"

    if [[ $((added+modified+deleted+untracked)) -ne 0 ]]; then
        [[ -n ${PL_GIT_DIRTY_FG} ]] && fg_color="${PL_GIT_DIRTY_FG}"
        [[ -n ${PL_GIT_DIRTY_BG} ]] && bg_color="${PL_GIT_DIRTY_BG}"
    fi

    local git_symbol content
    [[ ${untracked} -ne 0 ]] && content+="?${untracked} "
    [[ ${stashed} -ne 0 ]] && content+="§${stashed} "
    [[ ${added} -ne 0 ]] && content+="+${added} "
    [[ ${modified} -ne 0 ]] && content+="~${modified} "
    [[ ${deleted} -ne 0 ]] && content+="-${deleted} "
    [[ ${staged} -ne 0 ]] && content+="•${staged} "
    pl_symbol git_symbol 'git'
    content+="${git_symbol} ${branch}"
    [[ ${ahead} -ne 0 ]] && content+=" ↑${ahead}"
    [[ ${behind} -ne 0 ]] && content+=" ↓${behind}"
    add_segment "${content}" "$fg_color" "$bg_color"
}

