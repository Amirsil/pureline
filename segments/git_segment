#!/bin/env bash

# git_segment

PL_SYMBOLS+=(
    # GUI Font Symbols      # Standard Symbols for tty
    [git]=""               [tty_git]="╬" 
)

# -----------------------------------------------------------------------------
# append to prompt: git branch with indictors for;
#     number of; modified files, staged files and conflicts
# arg: $1 foreground color
# arg; $2 background color
# option variables;
#   PL_GIT_SHOW_STATUS
#   PL_GIT_DIRTY_FG
#   PL_GIT_DIRTY_BG
function git_segment {
    command -v git &> /dev/null  || return # exit early if no git

    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
    [[ -z ${branch}  ]] && return;  # return early if not a git branch

    local bg_color="$1"
    local fg_color="$2"
    local content symbol
    pl_symbol symbol 'git'
    content="${symbol} ${branch}"

    if ${PL_GIT_SHOW_STATUS:-true}; then
        local added=0
        local modified=0
        local staged=0
        local deleted=0
        local untracked=0
        local stashed=0
        local ahead=0
        local behind=0

        # Read through git status porcelain
        local state tracking
        local ifs=${IFS}; IFS='' # change IFS to stop leading spaces being stripped
        while read -r line; do
            state=${line:0:2}
            case ${state} in
                \#\#)           # branch line contains ahead/behind info
                    tracking=${line#*[}; tracking=${tracking%]*}
                    if [[ ${tracking} != "${line}" ]] ; then
                        [[ ${tracking} =~ (behind )([^,]*) ]] &&
                            behind=${BASH_REMATCH[0]/behind /}
                        [[ ${tracking} =~ (ahead )([^,]*) ]] &&
                            ahead=${BASH_REMATCH[0]/ahead /}
                    fi
                    ;;
                ?A)             # added but not staged
                    added=$((added+1))
                    ;;&
                ?D)             # deleted
                    deleted=$((deleted+1))
                    ;;&
                ?M|?R)          # modified/renamed but not staged
                    modified=$((modified+1))
                    ;;&
                M?|A?|D?|R?)    # changes staged to be commited
                    staged=$((staged+1))
                    ;;&
                \?\?)           # untracked
                    untracked=$((untracked+1))
            esac
        done <<< "$(git status -b --porcelain 2> /dev/null)"
        IFS=${ifs}    # change IFS back to stop breaking calling functions/loops

        stashed="$(git stash list 2>/dev/null | grep -F -v -c 'fatal:' | tr -d '[:space:]')"

        if [[ $((added+modified+deleted+untracked+staged)) -ne 0 ]]; then
            fg_color="${PL_GIT_DIRTY_FG:-${fg_color}}"
            bg_color="${PL_GIT_DIRTY_BG:-${bg_color}}"
        fi

        [[ ${untracked} -ne 0 ]] && content="?${untracked} ${content}"
        [[ ${stashed} -ne 0 ]] && content="§${stashed} ${content}"
        [[ ${added} -ne 0 ]] && content="+${added} ${content}"
        [[ ${modified} -ne 0 ]] && content="~${modified} ${content}"
        [[ ${deleted} -ne 0 ]] && content="-${deleted} ${content}"
        [[ ${staged} -ne 0 ]] && content="•${staged} ${content}"
        [[ ${ahead} -ne 0 ]] && content+=" ↑${ahead}"
        [[ ${behind} -ne 0 ]] && content+=" ↓${behind}"
    fi
    add_segment "${content}" "${fg_color}" "${bg_color}"
}

