#!/usr/bin/env bash

# PureLine - A Pure Bash Powerline PS1 Command Prompt
# This script should be sourced and not executed

# Global variables

# -----------------------------------------------------------------------------
# set default colors
declare -A PL_COLORS=(
    # copy paste from xresources color theme.
    [0]='0'     # black
    [1]='5'     # magenta
    [2]='8'     # bold black
    [3]='7'     # silver
    [4]='6'     # cyan
    [5]='14'    # bold cyan
    [6]='11'    # yellow
    [7]='15'    # white
    [8]='9'     # red
    [9]='1'     # br red
    [10]='3'    # yellow
    [12]='2'    # green
    [11]='10'   # bold green
    [14]='4'    # blue
    [13]='12'   # bold blue
    [15]='13'   # bold magenta
)

# -----------------------------------------------------------------------------
export -a PL_STYLES=(
    'classic'
    'lean'
    'slash'
    'reslash'
    'slashy'
    'reslashy'
)

# -----------------------------------------------------------------------------
# set separator symbols
declare -A PL_SEPARATORS=(
    [slash_hard]='◣'
    [slash_soft]='╲'

    [reslash_hard]='◤'
    [reslash_soft]='╱'

    [classic_hard]=''      # e0b0
    [classic_soft]=''      # e0b1

    [reslashy_hard]=''     # e0bc
    [reslashy_soft]=''     # e0bd

    [slashy_hard]=''       # e0b8
    [slashy_soft]=''       # e0b9
)

# -----------------------------------------------------------------------------
# default set of segments
declare -a PL_SEGMENTS=(
    'time'
    'host'
    'path'
    'git'
    'read_only'
    'newline'
    'prompt'
)

# -----------------------------------------------------------------------------
# segment symbols - these are set in the segment files
export -A PL_SYMBOLS=()

# -----------------------------------------------------------------------------
# set default options
declare -A PL_OPTIONS=(
    [style]='classic'           # lean / classic / slash(y) / reslash(y)
    [color]='paraiso'           # color schemes are located in pureline/colors
    [set_titlebar]=false        # by default we don't set the titlebar
    [titlebar]="\u@h: \w"       # titlebar can use PS1 style \u etc
    [erase_to_eol]=false        # needed by some terminals to prevent glitches

    [time_primary_color]=2
    [time_secondary_color]=7
    [time_show_seconds]=false   # hh:mm:ss|hh:mm

    [host_primary_color]=10
    [host_secondary_color]=0
    [host_enable_user]='ssh'    # always|never|ssh
    [host_enable_name]='ssh'    # always|never|ssh
    [host_enable_ip]='never'    # always|never|ssh
    [host_split]=false          # split user>host

    [path_primary_color]=13
    [path_secondary_color]=0
    [path_trim]=2                # 0-fullpath,1-current,n-trim
    [path_split]=true            # split path into segments

    [git_primary_color]=12
    [git_secondary_color]=0
    [git_primary_hilite]=8
    [git_secondary_hilite]=7

    [read_only_primary_color]=8
    [read_only_secondary_color]=0

    [prompt_primary_color]=2
    [prompt_secondary_color]=7
    [prompt_primary_hilite]=8
    [prompt_secondary_hilite]=0
)

# -----------------------------------------------------------------------------
# create config directories
#   ~/.config/pureline
#   ~/.config.pureline/colors
#   ~/.config/pureline/config
# a starter config file will be copied in
function _setup_directories() {
    export PL_DIR
    PL_DIR=${PL_DIR:-$(dirname "${BASH_SOURCE[0]}")''}
    export PL_CONFIG_DIR
    PL_CONFIG_DIR=${PL_CONFIG_DIR:-"${HOME}/.config/pureline"}

    if [[ ! -d "${PL_CONFIG_DIR}" ]]; then
        mkdir "${PL_CONFIG_DIR}"
        [[ -f "${PL_DIR}/configs/lean_full.conf" ]] &&
            cp "${PL_DIR}/configs/lean_full.conf" "${PL_CONFIG_DIR}/pureline.conf"
    fi
    [[ -d "${PL_CONFIG_DIR}/segments" ]] || mkdir "${PL_CONFIG_DIR}/segments"
    [[ -d "${PL_CONFIG_DIR}/colors" ]] || mkdir "${PL_CONFIG_DIR}/colors"
}

# -----------------------------------------------------------------------------
# returns an escaped color code for printing to terminal
# arg: $1 color array index and returns the formatted result by reference
# arg: $2 true/false is background
function _format_color {
    local -n _color=$1
    local isBackground=$2

    if [[ ${_color} == 'default' ]]; then
        [[ ${isBackground} == true ]] && _color='\e[49m' || _color='\e[0;39m'
    else
        local mode fgbg
        [[ ${PL_COLORS[${_color}]} =~ ';' ]] && mode='2' || mode='5'
        [[ ${isBackground} == true ]] && fgbg='48' || fgbg='38'
        _color="\e[${fgbg};${mode};${PL_COLORS[${_color}]}m"
    fi
    _color="\[${_color}\]"  # function return value
}

# -----------------------------------------------------------------------------
# returns a color formatted string with the powerline symbol for a segment end
# arg: $1 is used to return formatted symbol by reference
# arg: $2 is foreground color of the next segment
# arg: $3 is background color of the next segment
function _segment_end {
    local -n _end_symbol=$1
    local fg=$2
    local bg=$3

    if [[ ${PL_OPTIONS[style]} == 'lean' ]]; then
        _end_symbol=''
        return
    fi

    case "${__last_color}" in
        '')     # if no last color, this is the first segment
            _end_symbol=''
            ;;
        "$3")   # segment colors are the same, use a foreground separator
            _end_symbol="${PL_SEPARATORS[${PL_OPTIONS[style]}_'soft']}"
            ;;
        *)      # segment colors are different, use a background separator
            _end_symbol="${PL_SEPARATORS[${PL_OPTIONS[style]}_'hard']}"
            fg="${__last_color}"
    esac
    __last_color="${bg}"

    _format_color fg false
    _format_color bg true
    _end_symbol="${fg}${bg}${_end_symbol}"  # function return value
}

# -----------------------------------------------------------------------------
# helper function to add a formatted segment to the PS1
# arg: $1 string: content
# arg: $2 int: primary color
# arg: $3 int: secondary color
# arg: $4 boolean: lean style, if true box content with square brackets
function _append_segment {
    local content=$1
    local bg="${2:-7}"  # set bg to primary color (default to 7)
    local fg="${3:-0}"  # set fg to secondary color (default to 0)

    if [[ ${PL_OPTIONS[style]} == 'lean' ]]; then
        fg="${bg}"  # on lean style, switch primary color to foreground
        bg='default'
        [[ ${4:-true} == true ]] && content="[${content}]" || content="${content}"
    else
        local end_symbol
        _segment_end end_symbol "${fg}" "${bg}"
        [[ -n ${end_symbol} ]] && PS1+="${end_symbol}"
        content=" ${content} "
    fi

    _format_color fg false
    _format_color bg true
    PS1+="${fg}${bg}${content}"
}

# append to prompt: end the current promptline and start a newline
function _line_break {
    if [[ -n ${__last_color} ]]; then
        local end_symbol
        _segment_end end_symbol "${__last_color}" 'default'
        PS1+="${end_symbol}"
        if ${PL_OPTIONS[erase_to_eol]} ; then
            PS1+="\[\e[K\]"         # clear to end of line
        fi
    fi
    PS1+="\n"
    unset __last_color
}

# -----------------------------------------------------------------------------
# code to run at the beginning of $PROMT_COMMAND
function _pureline_pre {
    export __return_code=$? # save return code of last command
    if ${PL_OPTIONS[set_titlebar]:-false}; then
        if (( ${BASH_VERSINFO[0]:-0} > 4 ||
            (${BASH_VERSINFO[0]:-0} == 4 &&
            ${BASH_VERSINFO[1]:-0} >= 4) )); then
            echo -ne "\e]2;${PL_OPTIONS[titlebar]@P}\a"  # set the gui window title
        else
            echo -ne "\e]2;'${PL_OPTIONS[titlebar]}'\a"  # set the gui window title
        fi
    fi
}

# -----------------------------------------------------------------------------
# shellcheck disable=SC1090
function source_segment() {
    local segment_name=$1
        # first: try the pureline/segments folder
        if [[ -f "${PL_DIR}"'/segments/'"${segment_name}" ]]; then
            source "${PL_DIR}"'/segments/'"${segment_name}"
        else
            # second: try ~/.config/pureline/segments
            if [[ -f "${PL_CONFIG_DIR}"'/segments/'"${segment_name}" ]]; then
                source "${PL_CONFIG_DIR}"'/segments/'"${segment_name}"
            else
                return 1
            fi
        fi
        return 0
}

# -----------------------------------------------------------------------------
function _pureline_ps1 {
    local segment
    local content
    local hilite
    local primary_color
    local secondary_color

    # load the segments
    PS1=''
    for segment in "${PL_SEGMENTS[@]}"; do
        # try to run segment - if it has been hot loaded it will fail
        "_${segment}_segment" content hilite &>/dev/null
        # checking the segment function exists before running hurts performance
        # so we just run it and if it fails then try to deal with it.
        if [[ ${?} -eq 127 ]]; then
            source_segment "${segment}_segment"
            "_${segment}_segment" content hilite
        fi
        if [[ -n "${content}" ]]; then
            if [[ ${hilite} == true ]]; then
                primary_color="${PL_OPTIONS[${segment}_'primary_hilite']}"
                secondary_color="${PL_OPTIONS[${segment}_'secondary_hilite']}"
            else
                primary_color="${PL_OPTIONS[${segment}_'primary_color']}"
                secondary_color="${PL_OPTIONS[${segment}_'secondary_color']}"
            fi
            _append_segment \
                "${content}" \
                "${primary_color}" \
                "${secondary_color}" \
                "${PL_OPTIONS[${segment}'_decorate']:-true}"
            content=''
            hilite=false
        fi
    done

    # final end point
    if [[ -n ${PS1} ]]; then
        if [[ ${__last_color} != "default" ]]; then
            local end_symbol
            _segment_end end_symbol "${__last_color}" 'default'
            PS1+="${end_symbol} "
        fi
    else
        # No segments loaded, set a basic prompt
        PS1="plp: no segments \$ "
    fi

    # cleanup
    PS1+="\[\e[0m\]"            # color off
    if ${PL_OPTIONS[erase_to_eol]} ; then
        PS1+="\[\e[K\]"         # clear to end of line
    fi
    unset __last_color
    unset __return_code
}

# -----------------------------------------------------------------------------
# entry point to setup pureline
# shellcheck disable=SC1090
function _plp_init() {
    _setup_directories

    # check if an argument has been given for a config file
    if [[ -f $1 ]]; then
        source "$1"
    else
        # if not check the config dir for 'pureline.conf'
        [[ -f "${PL_CONFIG_DIR}/pureline.conf" ]] &&
            source "${PL_CONFIG_DIR}/pureline.conf"
    fi

    # source segments
    local idx
    local segment_name
    for idx in "${!PL_SEGMENTS[@]}"; do
        segment_name=${PL_SEGMENTS[${idx}]}'_segment'
        if ! source_segment "${segment_name}"; then
            printf "Segment not found: %s\n" "${segment_name}"
            unset PL_SEGMENTS["${idx}"]
        fi
    done

    # source color scheme
    if [[ -n ${PL_OPTIONS[color]} ]]; then
        # first: try the pureline/colors folder
        if [[ -f "${PL_DIR}"'/colors/'"${PL_OPTIONS[color]}" ]]; then
            source "${PL_DIR}"'/colors/'"${PL_OPTIONS[color]}"
        else
            # second: try ~/.config/pureline/colors
            if [[ -f "${PL_CONFIG_DIR}"'/colors/'"${PL_OPTIONS[color]}" ]]; then
                source "${PL_CONFIG_DIR}"'/colors/'"${PL_OPTIONS[color]}"
            else
                printf "Color scheme not found: %s\n" "${PL_OPTIONS[color]}"
            fi
        fi
    fi

    # source cli commands
    [[ -f "${PL_DIR}/commands" ]] && source "${PL_DIR}/commands"

    # install PureLine on the PROMPT_COMMAND to set the PS1
    if [[ ! ${PROMPT_COMMAND} =~ 'pureline_ps1' ]]; then
        [[ ! ${#PROMPT_COMMAND} -eq 0 ]] && PROMPT_COMMAND+=";"
        PROMPT_COMMAND="_pureline_pre; ${PROMPT_COMMAND} _pureline_ps1;"
    fi
}

if [[ "${BASH_SOURCE[0]}" -ef "$0" ]]; then
    printf "PureLine needs to be sourced, not executed.\n"
else
    [[ ${PL_TESTING:-false} != true ]] && _plp_init "${@}"
fi
