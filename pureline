#!/bin/env bash

# PureLine - A Pure Bash Powerline PS1 Command Prompt 

# -----------------------------------------------------------------------------
# returns a string with the powerline symbol for a segment end
# arg: $1 is foreground color of the next segment
# arg: $2 is background color of the next segment
function segment_end {
    if [ "$__last_color" == "$2" ]; then
        # segment colors are the same, use a foreground separator
        local end_char="${PL_SYMBOLS[soft_separator]}"
        local fg="$1"
    else
        # segment colors are different, use a background separator
        local end_char="${PL_SYMBOLS[hard_separator]}"
        local fg="$__last_color"
    fi
    if [ -n "$__last_color" ]; then
        echo "${PL_COLORS[$fg]}${PL_COLORS[On_$2]}$end_char"
    fi
}

# -----------------------------------------------------------------------------
# returns a string with background and foreground colours set
# arg: $1 foreground color
# arg: $2 background color
# arg: $3 content
function segment_content {
    echo "${PL_COLORS[$1]}${PL_COLORS[On_$2]}$3"
}

#------------------------------------------------------------------------------
# Helper function for User segment - also used in external ssh segment
function ip_address {
    # shellcheck disable=SC2005
    echo "$(ip route get 1 | tr -s ' ' | cut -d' ' -f7)"
}

#------------------------------------------------------------------------------
# Helper function to return normal or super user prompt character
function prompt_char {
    [[ ${EUID} -eq 0 ]] && echo "#" || echo "$"
}

# -----------------------------------------------------------------------------
# append to prompt: current time
# arg: $1 foreground color
# arg: $2 background color
# optional variables;
#   PL_TIME_SHOW_SECONDS: true/false for hh:mm:ss / hh:mm
function time_segment {
    local bg_color="$1"
    local fg_color="$2"
    if [ "$PL_TIME_SHOW_SECONDS" = true ]; then
        local content="\t"
    else
        local content="\A"
    fi
    PS1+="$(segment_end "$fg_color" "$bg_color")"
    PS1+="$(segment_content "$fg_color" "$bg_color" " $content ")"
    __last_color="$bg_color"
}

#------------------------------------------------------------------------------
# append to prompt: user@host or user or root@host
# arg: $1 foreground color
# arg: $2 background color
# option variables;
#   PL_USER_SHOW_HOST: true/false to show host name/ip
#   PL_USER_USE_IP: true/false to show IP instead of hostname
function user_segment {
    local bg_color="$1"
    local fg_color="$2"
    local content="\u"
    # Show host if true or when user is remote/root
    if [ "$PL_USER_SHOW_HOST" = true ]; then
        if [ "$PL_USER_USE_IP" = true ]; then
            content+="@$(ip_address)"
        else
            content+="@\h"
        fi
    fi
    PS1+="$(segment_end "$fg_color" "$bg_color")"
    PS1+="$(segment_content "$fg_color" "$bg_color" " $content ")"
    __last_color="$bg_color"
}

# -----------------------------------------------------------------------------
# append to prompt: current directory
# arg: $1 foreground color
# arg; $2 background color
# option variables;
#   PL_PATH_TRIM: 0â€”fullpath, 1â€”current dir, [x]â€”trim to x number of dir
function path_segment {
    local bg_color="$1"
    local fg_color="$2"
    local content="\w"
    if [ "$PL_PATH_TRIM" -eq 1 ]; then
        local content="\W"
    elif [ "$PL_PATH_TRIM" -gt 1 ]; then
        PROMPT_DIRTRIM="$PL_PATH_TRIM"
    fi
    PS1+="$(segment_end "$fg_color" "$bg_color")"
    PS1+="$(segment_content "$fg_color" "$bg_color" " $content ")"
    __last_color="$bg_color"
}

# -----------------------------------------------------------------------------
# append to prompt: the number of background jobs running
# arg: $1 foreground color
# arg; $2 background color
function background_jobs_segment {
    local bg_color="$1"
    local fg_color="$2"
    local number_jobs
    number_jobs=$(jobs -p | wc -l | tr -d '[:space:]')
    if [ ! "$number_jobs" -eq 0 ]; then
        PS1+="$(segment_end "$fg_color" "$bg_color")"
        PS1+="$(segment_content "$fg_color" "$bg_color" " ${PL_SYMBOLS[background_jobs]} $number_jobs ")"
        __last_color="$bg_color"
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: indicator is the current directory is ready-only
# arg: $1 foreground color
# arg; $2 background color
function read_only_segment {
    local bg_color="$1"
    local fg_color="$2"
    if [ ! -w "$PWD" ]; then
        PS1+="$(segment_end "$fg_color" "$bg_color")"
        PS1+="$(segment_content "$fg_color" "$bg_color" " ${PL_SYMBOLS[read_only]} ")"
        __last_color="$bg_color"
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: append a '$' prompt with optional return code for previous command
# arg: $1 foreground color
# arg; $2 background color
function prompt_segment {
    local bg_color="$1"
    local fg_color="$2"
    local content
    content=" $(prompt_char) "
    if [ ${EUID} -eq 0 ]; then
        if [ -n "$PL_PROMPT_ROOT_FG" ]; then
            fg_color="$PL_PROMPT_ROOT_FG"
        fi
        if [ -n "$PL_PROMPT_ROOT_BG" ]; then
            bg_color="$PL_PROMPT_ROOT_BG"
        fi
    fi
    PS1+="$(segment_end "$fg_color" "$bg_color")"
    PS1+="$(segment_content "$fg_color" "$bg_color" "$content")"
    __last_color="$bg_color"
}

# -----------------------------------------------------------------------------
# append to prompt: append a '$' prompt with optional return code for previous command
# arg: $1 foreground color
# arg; $2 background color
function return_code_segment {
    if [ ! "$__return_code" -eq 0 ]; then
        local bg_color="$1"
        local fg_color="$2"
        local content=" ${PL_SYMBOLS[return_code]} $__return_code "
        PS1+="$(segment_end "$fg_color" "$bg_color")"
        PS1+="$(segment_content "$fg_color" "$bg_color" "$content")"
        __last_color="$bg_color"
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: end the current promptline and start a newline
function newline_segment {
    if [ -n "$__last_color" ]; then
        PS1+="$(segment_end "$__last_color" 'Default')"
    fi
    PS1+="\n"
    unset __last_color
}

# -----------------------------------------------------------------------------
function pureline_ps1 {
    __return_code=$?    # save the return code
    local TITLEBAR='\[\e]2; \u@\h: \w \a'  # set console title
                                            # example: {USERNAME}@{HOSTNAME}:{PWD}
    segment_dir=$(dirname "${BASH_SOURCE[0]}")'/segments'

    PS1=""                                  # reset the command prompt

    # load the segments
    for segment in "${!PL_SEGMENTS[@]}"; do
        # check if segment function is not defined
        if [ -z "$(type -t ${PL_SEGMENTS[$segment]})" ]; then
            # if not defined, source external function
            source $segment_dir'/'${PL_SEGMENTS[segment]% *};
        fi
        ${PL_SEGMENTS[$segment]};
    done

    # final end point
    if [ -n "$__last_color" ]; then
        PS1+="$(segment_end "$__last_color" 'Default')"
    else
        # No segments loaded, set a basic prompt
        PS1="PL | No segments Loaded: $(prompt_char)"
    fi

    # cleanup
    PS1+="${PL_COLORS[Color_Off]}"
    if [ "$PL_ERASE_TO_EOL" = true ]; then
        PS1+="\[\e[K\]"
    fi
    PS1+=" ${TITLEBAR}" # set titlebar
    unset __last_color
    unset __return_code
}

# -----------------------------------------------------------------------------

# define the basic color set
declare -A PL_COLORS=(
[Color_Off]='\[\e[0m\]'       # Text Reset
# Foreground
[Default]='\[\e[0;39m\]'      # Default
[Black]='\[\e[0;30m\]'        # Black
[Red]='\[\e[0;31m\]'          # Red
[Green]='\[\e[0;32m\]'        # Green
[Yellow]='\[\e[0;33m\]'       # Yellow
[Blue]='\[\e[0;34m\]'         # Blue
[Purple]='\[\e[0;35m\]'       # Purple
[Cyan]='\[\e[0;36m\]'         # Cyan
[White]='\[\e[0;37m\]'        # White
# Background
[On_Default]='\[\e[49m\]'     # Default
[On_Black]='\[\e[40m\]'       # Black
[On_Red]='\[\e[41m\]'         # Red
[On_Green]='\[\e[42m\]'       # Green
[On_Yellow]='\[\e[43m\]'      # Yellow
[On_Blue]='\[\e[44m\]'        # Blue
[On_Purple]='\[\e[45m\]'      # Purple
[On_Cyan]='\[\e[46m\]'        # Cyan
[On_White]='\[\e[47m\]'       # White
)

# default symbols are intended for 'out-ofthe-box' compatibility.
# symbols from code page 437: character set of the original IBM PC
declare -A PL_SYMBOLS=(
[hard_separator]="â–¶"
[soft_separator]="â”‚"

[read_only]="Î˜"
[return_code]="x"
[background_jobs]="â†¨"
[background_jobs]="â†”"

[ssh]="â•¤"
[screen]="ðŸ’»"
)

# check if an argument has been given for a config file
if [ -f "$1" ]; then
    # shellcheck disable=SC1090
    source "$1"
fi
# ensure some segments have been defined
if [ -z "$PL_SEGMENTS" ]; then
    # define default segments to load
    declare -a PL_SEGMENTS=(
    'user_segment        Yellow      Black'
    'path_segment        Blue        Black'
    'read_only_segment   Red         White'
    )
    PL_USER_SHOW_HOST=true
    PL_PATH_TRIM=1
    # don't clobber readline mode indicator
    [[ $(bind -v) =~ "set show-mode-in-prompt off" ]] && PL_ERASE_TO_EOL=true
fi

# dynamically set the  PS1
# shellcheck disable=SC2015
[[ ! ${PROMPT_COMMAND} =~ 'pureline_ps1;' ]] && PROMPT_COMMAND="$PROMPT_COMMAND; pureline_ps1" || true

