#!/bin/env bash

# PureLine - A Pure Bash Powerline PS1 Command Prompt 
# This script should be sourced and not executed

# Global variables

declare -A PL_SYMBOLS   # Hash table to reference symbols
declare -A PL_COLORS    # Hash table to reference colors
declare -a PL_SEGMENTS  # Array to hold segments and their arguments

# -----------------------------------------------------------------------------
# returns a symbol depending on the value of PL_STYLE
# arg: S1 returns the symbol by reference
# arg: S2 is the symbol to lookup
function pl_symbol {
    local -n _symbol=$1
    if [[ ${PL_STYLE} != 'lean' ]]; then
        _symbol="${PL_SYMBOLS[${PL_STYLE}_${2}]}"
        # if style symbol not set, fallback to generic
        [[ -z ${_symbol} ]] && _symbol="${PL_SYMBOLS[${2}]}"
        [[ -n ${_symbol} ]] && _symbol="${_symbol}"
    fi
}

# -----------------------------------------------------------------------------
# returns an escaped color code for printing to terminal
# arg: $1 color array index and returns the formatted result by refernce
# arg: $2 true/false is background
function format_color {
    local -n _color=$1
    local isBackground=$2

    if [[ ${_color} == 'default' ]]; then
        [[ ${isBackground} == true ]] && _color='\e[49m' || _color='\e[0;39m'
    else
        local mode fgbg
        [[ ${PL_COLORS[${_color}]} =~ ';' ]] && mode='2' || mode='5'
        [[ ${isBackground} == true ]] && fgbg='48' || fgbg='38'
        _color="\e[${fgbg};${mode};${PL_COLORS[${_color}]}m"
    fi
    _color="\[${_color}\]"  # function return value
}

# -----------------------------------------------------------------------------
# returns a string with the powerline symbol for a segment end
# arg: $1 is used to return formatted symbol by reference
# arg: $2 is foreground color of the next segment
# arg: $3 is background color of the next segment
function segment_end {
    local -n _end_symbol=$1
    local fg bg=$3

    if [[ ${PL_STYLE} == 'lean' ]]; then
        _end_symbol=''
        return
    fi

    case "${__last_color}" in
        '')     # if no last color, this is the first segment
            _end_symbol=''
            fg="$2"
            ;;
        "$3")   # segment colors are the same, use a foreground separator
            pl_symbol _end_symbol 'soft_separator'
            fg="$2"
            ;;
        *)      # segment colors are different, use a background separator
            pl_symbol _end_symbol 'hard_separator'
            fg="${__last_color}"
    esac
    __last_color="${bg}"

    format_color fg false
    format_color bg true
    _end_symbol="${fg}${bg}${_end_symbol}"  # function return value
}

# -----------------------------------------------------------------------------
# helper function to add a formatted segment to the PS1
# arg: $1 string: content
# arg: $2 int: foreground color
# arg: $3 int: background color
# arg: $4 boolean: style it
function add_segment {
    local content=$1
    local fg=$2
    local bg=$3

    if [[ ${PL_STYLE} == 'lean' ]]; then
        fg="${bg}"
        bg='default'
        [[ ${4:-true} == true ]] && content="[${content}]"
    else
        local end_symbol
        segment_end end_symbol "${fg}" "${bg}"
        [[ -n ${end_symbol} ]] && PS1+="${end_symbol}"
        content=" ${content} "
    fi

    format_color fg false
    format_color bg true
    PS1+="${fg}${bg}${content}"
}

# Helper function for User segment - also used in external ssh segment
# arg: $1 return value for result of cuntion
function ip_address {
    local -n _ip_address=$1

    # check if the ip command exists
    if command -v ip &> /dev/null ; then
        # shellcheck disable=SC2005
        _ip_address="$(ip route get 1 | tr -s ' ' | cut -d' ' -f7)"
    elif command -v ifconfig &> /dev/null ; then
        local _ip
        while IFS=$': \t' read -ra _line ;do
            [[ -z "${_line%inet}" ]] &&
                _ip=${_line[${#_line[1]}>4?1:2]} &&
                [[ ${_ip#127.0.0.1} ]] && _ip_address=${_ip}
        done< <(LANG=C /sbin/ifconfig)
    else
        # shellcheck disable=SC2034
        _ip_address='127.0.0.1'
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: current time
# arg: $1 foreground color
# arg: $2 background color
# optional variables;
#   PL_TIME_SHOW_SECONDS: true/false for hh:mm:ss / hh:mm
function time_segment {
    local bg_color="$1"
    local fg_color="$2"
    local content
    if ${PL_TIME_SHOW_SECONDS} ; then
        content="\t"
    else
        content="\A"
    fi
    add_segment "${content}" "${fg_color}" "${bg_color}"
}

#------------------------------------------------------------------------------
# append to prompt: user@host or user or root@host
# arg: $1 foreground color
# arg: $2 background color
# option variables;
#   PL_USER_SHOW_HOST: true/false to show host name/ip
#   PL_USER_USE_IP: true/false to show IP instead of hostname
function user_segment {
    local bg_color="$1"
    local fg_color="$2"
    local content="\u"
    # Show host 'user@hostname' or ip 'user@127.0.0.1'
    if ${PL_USER_SHOW_HOST} ; then
        if ${PL_USER_USE_IP} ; then
            local ip
            ip_address ip
            content+="@${ip}"
        else
            content+="@\h"
        fi
    fi
    add_segment "${content}" "${fg_color}" "${bg_color}"
}

# -----------------------------------------------------------------------------
# append to prompt: current directory
# arg: $1 foreground color
# arg; $2 background color
# option variables;
#   PL_PATH_TRIM: 0—fullpath, 1—current dir, [x]—trim to x number of dir
function path_segment {
    local bg_color="$1"
    local fg_color="$2"
    local content

    if ${PL_PATH_SPLIT:-false}; then
        # split directories into segments
        content="${PWD/#${HOME}/\~}"
        if [[ ${PL_PATH_TRIM} -eq 1 ]]; then
            # show only current dir from end of path
            content="${content##*/}"
        elif [[ ${PL_PATH_TRIM} -gt 1 ]]; then
            local re=")$"
            local ree="\/[^\/]*"
            for (( i = 0; i < PL_PATH_TRIM; i++ )); do
                re="${ree}${re}"
            done
            re="(${re}"
            [[ ${content} =~ ${re} ]]
            ret=${BASH_REMATCH[1]}
            [[ ${#ret} -gt 0 ]] && content="…${ret}"
        fi
        local sep
        pl_symbol sep 'soft_separator'
        content="${content//\// ${sep} }"
        [[ ${content:0:2} == " ${sep}" ]] && content="/${content}"
        [[ ${content: -2} == "${sep} " ]] && content=${content%%???}
    else
        # show path in single segment
        content="\w"
        if [[ ${PL_PATH_TRIM} -eq 1 ]]; then
            content="\W"
        elif [[ ${PL_PATH_TRIM} -gt 1 ]]; then
            PROMPT_DIRTRIM="${PL_PATH_TRIM}"
        fi
    fi
    add_segment "${content}" "${fg_color}" "${bg_color}"
}

# -----------------------------------------------------------------------------
# append to prompt: the number of background jobs running
# arg: $1 foreground color
# arg; $2 background color
function background_jobs_segment {
    local number_jobs=0
    # count the number of jobs, excluding those marked as 'Done'
    while read -r line ; do
        [[ -n ${line} && ! ${line} =~ 'Done' ]] && number_jobs=$((number_jobs+1))
    done <<< "$(jobs)"
    if [[ ${number_jobs} -ne 0 ]]; then
        local bg_color="$1"
        local fg_color="$2"
        local bj_symbol
        pl_symbol bj_symbol "background_jobs"
        local content="${bj_symbol} ${number_jobs}"
        add_segment "${content}" "${fg_color}" "${bg_color}"
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: indicator is the current directory is ready-only
# arg: $1 foreground color
# arg; $2 background color
function read_only_segment {
    [[ -w ${PWD} ]] && return   # if current directory is writeable, do nothing

    local bg_color="$1"
    local fg_color="$2"
    local ro_symbol
    pl_symbol ro_symbol "read_only"
    local content="${ro_symbol}"
    add_segment "${content}" "${fg_color}" "${bg_color}"
}

# -----------------------------------------------------------------------------
# append to prompt: append a '$' prompt with optional return code for previous command
# arg: $1 foreground color
# arg; $2 background color
function prompt_segment {
    local bg_color="$1"
    local fg_color="$2"
    local prompt_char='$'

    # if user is root, change the segment colors and prompt
    if [[ ${EUID} -eq 0 ]]; then
        [[ -n ${PL_PROMPT_ROOT_FG} ]] && fg_color="${PL_PROMPT_ROOT_FG}"
        [[ -n ${PL_PROMPT_ROOT_BG} ]] && bg_color="${PL_PROMPT_ROOT_BG}"
        prompt_char='#'
    fi
    add_segment "${prompt_char}" "${fg_color}" "${bg_color}" false
}

# -- ---------------------------------------------------------------------------
# append to prompt: show when a commnd return code is available
# arg: $1 foreground color
# arg; $2 background color
function return_code_segment {
    # don't show if success (0) or ctrl-c (130)
    [[ ${__return_code} -eq 0 || ${__return_code} -eq 130 ]] && return

    local bg_color="$1"
    local fg_color="$2"
    local content rc_symbol
    pl_symbol rc_symbol 'return_code'
    content="${rc_symbol} ${__return_code}"
    add_segment "${content}" "${fg_color}" "${bg_color}"
    __return_code=0
}

# -----------------------------------------------------------------------------
# append to prompt: end the current promptline and start a newline
function newline_segment {
    if [[ -n ${__last_color} ]]; then
        local end_symbol
        segment_end end_symbol "${__last_color}" 'default'
        PS1+="${end_symbol}"
    fi
    PS1+="\n"
    unset __last_color
}

# -----------------------------------------------------------------------------
# code to run before processing $PROMT_COMMAND
function pureline_pre {
    __return_code=$? # save return code of last command
    [[ ${PL_SET_TITLEBAR} == true ]] && echo -ne "\e]2;${PL_TITLEBAR@P}\a"  # set the gui window title
}

# -----------------------------------------------------------------------------
function pureline_ps1 {
    PS1=""                                  # reset the command prompt

    # load the segments
    local segment_index
    for segment_index in "${!PL_SEGMENTS[@]}"; do
        ${PL_SEGMENTS[${segment_index}]};
    done

    # final end point
    if [[ -n ${PS1} ]]; then
        local end_symbol
        segment_end end_symbol "${__last_color}" 'default'
        PS1+="${end_symbol} "
    else
        # No segments loaded, set a basic prompt
        PS1="No PureLine Segments: ${PL_PROMPT_CHAR}"
    fi

    # cleanup
    PS1+="\[\e[0m\]"            # color off
    if ${PL_ERASE_TO_EOL} ; then
        PS1+="\[\e[K\]"         # clear to end of line
    fi
    unset __last_color
    unset __return_code
}

# -----------------------------------------------------------------------------
# define the basic color set
function set_default_colors() {
    PL_COLORS=(
        # copy paste from xresources color theme.
        # duplicated here for convenience when running PureLine without
        # supporting files.
        [0]='0'     # black
        [1]='5'     # magenta
        [2]='8'     # bold black
        [3]='7'     # silver
        [4]='6'     # cyan
        [5]='14'    # bold cyan
        [6]='11'    # yellow
        [7]='15'    # white
        [8]='9'     # red
        [9]='1'     # br red
        [10]='3'    # yellow
        [12]='2'    # green
        [11]='10'   # bold green
        [14]='4'    # blue
        [13]='12'   # bold blue
        [15]='13'   # bold magenta
    )
}

# -----------------------------------------------------------------------------
# basic symbols for segment separators and builtins
function set_default_symbols {
    [[ ${#PL_SYMBOLS[@]} -ne 0 ]] && return # symbols already set
    PL_SYMBOLS+=(
        [classic_hard_separator]=''
        [classic_soft_separator]=''

        [reslash_hard_separator]='◤'
        [reslash_soft_separator]='╱'

        [slash_hard_separator]='◣'
        [slash_soft_separator]='╲'

        [read_only]=''

        [return_code]='⚑'

        [background_jobs]="⏎"
    )
}

# -----------------------------------------------------------------------------
# default basic set of segments
function set_default_config {
    PL_SEGMENTS=(
        'user_segment        2      7'
        'path_segment        13     7'
        'read_only_segment   15     7'
    )
    PL_USER_SHOW_HOST=true
    PL_PATH_TRIM=2
    PL_TIME_SHOW_SECONDS=false
    PL_USER_USE_IP=false
    # set some defaults
    PL_STYLE='classic'      # use the classic powerline symbols
    PL_COLOR=''             # using default color set
    PL_SET_TITLEBAR=false   # by default we don't set titlebar
    PL_TITLEBAR="\u@\h: \w" # title bar can use PS1 style \u etc
    PL_ERASE_TO_EOL=false   # need on some terminals to prevent glitches
}

# -----------------------------------------------------------------------------
# entry point to setup pureline
function main() {
    local segment_index
    local segment_function

    set_default_colors
    set_default_symbols
    set_default_config

    # check if an argument has been given for a config file
    # shellcheck disable=SC1090
    [[ -f $1 ]] && source "$1"

    # source external segments
    export PL_DIR
    PL_DIR=$(dirname "${BASH_SOURCE[0]}")''
    for segment_index in "${!PL_SEGMENTS[@]}"; do
        # check if segment function is not defined
        # TODO: change to if segment file exists then load it
        segment_function=${PL_SEGMENTS[${segment_index}]%% *}
        if [[ -z "$(type -t "${segment_function}")" ]]; then
            # if not defined, source external function
            # shellcheck disable=SC1090
            source "${PL_DIR}"'/segments/'"${segment_function}"
        fi
    done
    # shellcheck disable=SC1090
    [[ -n ${PL_COLOR} ]] && source "${PL_DIR}"'/colors/'"${PL_COLOR}"

    # dynamically set the  PS1
    # shellcheck disable=SC2015
    if [[ ! ${PROMPT_COMMAND} =~ 'pureline_ps1' ]]; then
        # TODO strip trailing whitespace from PROMPT_COMMAND and check 
        # if last char is a semicolon
        [[ ! ${#PROMPT_COMMAND} -eq 0 ]] && PROMPT_COMMAND+=";"
        PROMPT_COMMAND="pureline_pre; ${PROMPT_COMMAND} pureline_ps1;"
    fi
}

main "${@}"

