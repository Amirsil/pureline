#!/usr/bin/env bash

# PureLine - A Pure Bash Powerline PS1 Command Prompt
# This script should be sourced and not executed

# Global variables

# -----------------------------------------------------------------------------
# color scheme - sourced from pureline/colors files
declare -A PL_COLORS=()

# -----------------------------------------------------------------------------
# styles are 2 character strings defining the separators.
#   first character used between segments of differing color
#   second character used between segments of same color
declare -A PL_STYLES=(
    [lean]=''       # no symbols, 
    [classic]=''  # classic powerline
    [slash]='◣╲'    # ascii symbols for slash (possible render issues)
    [reslash]='◤╱'  # reverse of asci slash
    [slashy]=''   # alt powerline style
    [reslashy]='' # reverse of powerline slashy
)

# -----------------------------------------------------------------------------
# default set of segments
declare -a PL_SEGMENTS=(
    'time'
    'host'
    'path'
    'git'
    'read_only'
    'newline'
    'prompt'
)

# -----------------------------------------------------------------------------
# set default options
declare -A PL_OPTIONS=(
    [style]='classic'           # lean / classic / slash(y) / reslash(y)
    [color]='xresources'        # color schemes are located in pureline/colors
    [set_titlebar]=false        # by default we don't set the titlebar
    [titlebar]="\u@h: \w"       # titlebar can use PS1 style \u etc
    [erase_to_eol]=false        # needed by some terminals to prevent glitches
)

# -----------------------------------------------------------------------------
# create config directories
#   ~/.config/pureline
#   ~/.config.pureline/colors
#   ~/.config/pureline/config
# a starter config file will be copied in
function _setup_directories {
    export PL_DIR
    PL_DIR=${PL_DIR:-$(dirname "${BASH_SOURCE[0]}")''}
    export PL_CONFIG_DIR
    PL_CONFIG_DIR=${PL_CONFIG_DIR:-"${HOME}/.config/pureline"}

    if [[ ! -d "${PL_CONFIG_DIR}" ]]; then
        mkdir "${PL_CONFIG_DIR}"
        [[ -f "${PL_DIR}/configs/lean_full.conf" ]] &&
            cp "${PL_DIR}/configs/lean_full.conf" "${PL_CONFIG_DIR}/pureline.conf"
    fi
    [[ -d "${PL_CONFIG_DIR}/segments" ]] || mkdir "${PL_CONFIG_DIR}/segments"
    [[ -d "${PL_CONFIG_DIR}/colors" ]] || mkdir "${PL_CONFIG_DIR}/colors"
}

# -----------------------------------------------------------------------------
# returns an escaped color code for printing to terminal
# arg: $1 input: color array index / output: formatted string by reference
# arg: $2 true/false is background
function _format_color {
    local -n _result=$1
    local isBackground=$2

    if [[ ${_result} == 'default' ]]; then
        [[ ${isBackground} == true ]] && _result='\e[49m' || _result='\e[0;39m'
    else
        local mode fgbg
        [[ ${PL_COLORS[${_result}]} =~ ';' ]] && mode='2' || mode='5'
        [[ ${isBackground} == true ]] && fgbg='48' || fgbg='38'
        _result="\e[${fgbg};${mode};${PL_COLORS[${_result}]:-${_result}}m"
    fi
    _result="\[${_result}\]"  # function return value
}

# -----------------------------------------------------------------------------
# returns a color formatted string with symbol for a segment separator
# arg: $1 is used to return formatted symbol by reference
# arg: $2 is foreground color of the next segment
# arg: $3 is background color of the next segment
function _get_separator {
    local -n _result=$1
    local fg=$2
    local bg=$3

    [[ ${PL_OPTIONS[style]} == 'lean' ]] && return

    case "${__last_color}" in
        '')     # if no last color, this is the first segment
            _result=''
            ;;
        "$3")   # segment colors are the same, use a foreground separator
            _result="${PL_STYLES[${PL_OPTIONS[style]}]:1:1}"
            ;;
        *)      # segment colors are different, use a background separator
            _result="${PL_STYLES[${PL_OPTIONS[style]}]:0:1}"
            fg="${__last_color}"
    esac
    __last_color="${bg}"

    if [[ -n ${_result} ]]; then
        _format_color fg false
        _format_color bg true
        _result="${fg}${bg}${_result}"  # function return value
    fi
}

# -----------------------------------------------------------------------------
# returns a string switching off color and optionally erasing rest of the line
# arg: $1 is used to return the resulting string by reference
function _get_eol {
    local -n _result=$1
    _result="\[\e[0m\]"            # color off
    if ${PL_OPTIONS[erase_to_eol]}; then
        _result+="\[\e[K\]"         # clear to end of line
    fi
}

# -----------------------------------------------------------------------------
# helper function to add a formatted segment to the PS1
# arg: $1 input: plain content / output: formatted & colored content
# arg: $2 int: primary color
# arg: $3 int: secondary color
# arg: $4 boolean: lean style, if true box content with square brackets
function _style_segment {
    local -n _result=$1
    local bg=${2:-7}  # set bg to primary color (default to 7)
    local fg=${3:-0}  # set fg to secondary color (default to 0)
    local separator

    if [[ ${PL_OPTIONS[style]} == 'lean' ]]; then
        fg="${bg}"  # on lean style, switch primary color to foreground
        bg='default'
        [[ ${4:-true} == false || ${_result} == '\n' ]] && 
            _result=" ${_result}" ||
            _result="[${_result}]"
    else
        if [[ ${_result} == '\n' ]]; then
            local eol
            _get_eol eol
            # _result="\[\e[0m\]${_result}${eol}"
            _result="${eol}${_result}"
            _get_separator separator "${fg}" "default"
            unset __last_color
        else
            _get_separator separator "${fg}" "${bg}"
            _result=" ${_result} "
        fi
    fi

    _format_color fg false
    _format_color bg true
    _result="${separator}${fg}${bg}${_result}"
}

# -----------------------------------------------------------------------------
# shellcheck disable=SC1090
function _source_segment {
    local segment_name=$1

    # first: try the pureline/segments folder
    if [[ -f "${PL_DIR}"'/segments/'"${segment_name}" ]]; then
        source "${PL_DIR}"'/segments/'"${segment_name}"
    else
        # second: try ~/.config/pureline/segments
        if [[ -f "${PL_CONFIG_DIR}"'/segments/'"${segment_name}" ]]; then
            source "${PL_CONFIG_DIR}"'/segments/'"${segment_name}"
        else
            return 1
        fi
    fi
    return 0
}

# -----------------------------------------------------------------------------
# shellcheck disable=SC1090
function _source_color_scheme {
    local color_scheme=$1
    # source color scheme
    if [[ -n ${color_scheme} ]]; then
        # first: try the pureline/colors folder
        if [[ -f "${PL_DIR}"'/colors/'"${color_scheme}" ]]; then
            source "${PL_DIR}"'/colors/'"${PL_OPTIONS[color]}"
        else
            # second: try ~/.config/pureline/colors
            if [[ -f "${PL_CONFIG_DIR}"'/colors/'"${color_scheme}" ]]; then
                source "${PL_CONFIG_DIR}"'/colors/'"${color_scheme}"
            else
                printf "Color scheme not found: %s\n" "${color_scheme}"
            fi
        fi
    fi

}

# -----------------------------------------------------------------------------
# code to run at the beginning of $PROMT_COMMAND
function _pureline_pre {
    export __return_code=$? # save return code of last command

    # check color scheme has been sourced
    [[ ${PL_OPTIONS[color]} != "${PL_COLORS[name]}" ]] &&
        _source_color_scheme "${PL_OPTIONS[color]}"

    if ${PL_OPTIONS[set_titlebar]:-false}; then
        if (( ${BASH_VERSINFO[0]:-0} > 4 ||
            (${BASH_VERSINFO[0]:-0} == 4 &&
            ${BASH_VERSINFO[1]:-0} >= 4) )); then
            echo -ne "\e]2;${PL_OPTIONS[titlebar]@P}\a"  # set the gui window title
        else
            echo -ne "\e]2;'${PL_OPTIONS[titlebar]}'\a"  # set the gui window title
        fi
    fi
}

# -----------------------------------------------------------------------------
function _get_segment_colors {
    local -n _primary_color=$1
    local -n _secondary_color=$2
    local hilite=$3
    if [[ ${hilite} == true ]]; then
        _primary_color="${PL_OPTIONS[${segment}_'primary_hilite']}"
        _secondary_color="${PL_OPTIONS[${segment}_'secondary_hilite']}"
    else
        _primary_color="${PL_OPTIONS[${segment}_'primary_color']}"
        _secondary_color="${PL_OPTIONS[${segment}_'secondary_color']}"
    fi
}

# -----------------------------------------------------------------------------
function _compile_ps1 {
    local -n result=$1
    local segment
    local content
    local hilite
    local primary_color
    local secondary_color

    # load the segments
    for segment in "${PL_SEGMENTS[@]}"; do
        content=''
        hilite=false
        "_${segment}_segment" content hilite
        if [[ -n "${content}" ]]; then
            _get_segment_colors primary_color secondary_color "${hilite}"
            _style_segment \
                content \
                "${primary_color}" \
                "${secondary_color}" \
                "${PL_OPTIONS[${segment}'_decorate']:-true}"
            result+="${content}"
        fi
    done

    # final end point
    if [[ -n ${result} ]]; then
        if [[ ${__last_color} != "default" ]]; then
            local end_symbol
            _get_separator end_symbol "${__last_color}" 'default'
            result+="${end_symbol} "
        fi
    fi

    # cleanup
    local eol
    _get_eol eol
    result+="${eol}"
    unset __last_color
    unset __return_code
}

# -----------------------------------------------------------------------------
function _set_pureline_ps1 {
    local new_PS1
    _compile_ps1 new_PS1
    [[ -n ${new_PS1} ]] &&
        PS1="${new_PS1}" ||
        printf "PureLine failed to set the prompt\n"
}

# -----------------------------------------------------------------------------
# entry point to setup pureline
# shellcheck disable=SC1090
function _plp_init() {
    _setup_directories

    # check if an argument has been given for a config file
    if [[ -f $1 ]]; then
        source "$1"
    else
        # if not check the config dir for 'pureline.conf'
        [[ -f "${PL_CONFIG_DIR}/pureline.conf" ]] &&
            source "${PL_CONFIG_DIR}/pureline.conf"
    fi

    # source segments
    local idx
    local segment_name
    for idx in "${!PL_SEGMENTS[@]}"; do
        segment_name=${PL_SEGMENTS[${idx}]}'_segment'
        if ! _source_segment "${segment_name}"; then
            printf "Segment not found: %s\n" "${segment_name}"
            unset PL_SEGMENTS["${idx}"]
        fi
    done

    # source cli commands
    [[ -f "${PL_DIR}/commands" ]] && source "${PL_DIR}/commands"

    # install PureLine on PROMPT_COMMAND 
    if [[ ! ${PROMPT_COMMAND} =~ 'pureline_ps1' ]]; then
        [[ ! ${#PROMPT_COMMAND} -eq 0 ]] && PROMPT_COMMAND+=";"
        PROMPT_COMMAND="_pureline_pre; ${PROMPT_COMMAND} _set_pureline_ps1;"
    fi
}

if [[ "${BASH_SOURCE[0]}" -ef "$0" ]]; then
    printf "PureLine needs to be sourced, not executed.\n"
else
    [[ ${PL_TESTING:-false} != true ]] && _plp_init "${@}"
fi
