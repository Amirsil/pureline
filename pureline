#!/bin/env bash

# PureLine - A Pure Bash Powerline PS1 Command Prompt 
# This script should be sourced and not executed

# Global variables

declare -A PL_SYMBOLS   # Hash table to reference symbols
declare -A PL_COLORS    # Hash table to reference colors
declare -a PL_SEGMENTS  # Array to hold segments and their arguments

# -----------------------------------------------------------------------------
# returns a symbol depending on the value of PL_STYLE
# arg: S1 is the symbol to lookup
function pl_symbol {
    local segment_symbol
    segment_symbol="${PL_SYMBOLS[${PL_STYLE}_${1}]}"
    # if symbol not set, fallback to basic
    if [[ -z ${segment_symbol} ]]; then
        segment_symbol="${PL_SYMBOLS[${1}]}"
    fi
    echo "$segment_symbol"
}

# -----------------------------------------------------------------------------
# returns an escaped color code for printing to terminal
# arg: $1 color array index
# arg: $2 true/false is background
# arg: $3 escape the colors or not
function format_color {
    local -n color=$1
    local background=$2
    local mode fgbg escape="${3:-true}"

    [[ ${PL_COLORS[$color]} =~ ';' ]] && mode='2' || mode='5'
    [[ $background = true ]] && fgbg='48' || fgbg='38'
    case $color in
        fg_default)
            color='\e[0;39m'     # use default foreground color
            ;;
        bg_default)
            color='\e[49m'       # use default background color
            ;;
        *)
            color="\e[${fgbg};${mode};${PL_COLORS[$color]}m"
            ;;
    esac
    [[ $escape == true ]] && color="\[$color\]"
}

# -----------------------------------------------------------------------------
# returns a string with the powerline symbol for a segment end
# arg: $1 is foreground color of the next segment
# arg: $2 is background color of the next segment
function segment_end {
    local end_char fg bg=$2

    [[ -z $__last_color ]] && return

    if [[ $__last_color == "$2" ]]; then
        # segment colors are the same, use a foreground separator
        end_char=$(pl_symbol "soft_separator")
        fg="$1"
    else
        # segment colors are different, use a background separator
        end_char=$(pl_symbol "hard_separator")
        fg="$__last_color"
    fi

    format_color fg false
    format_color bg true
    echo "$fg$bg$end_char"
}

# -----------------------------------------------------------------------------
# returns a string with background and foreground colours set
# arg: $1 foreground color
# arg: $2 background color
# arg: $3 content
function segment_content {
    local fg=$1
    local bg=$2
    __last_color="$2"
    format_color fg false
    format_color bg true
    echo "$fg$bg$3"
}

#------------------------------------------------------------------------------
# Helper function for User segment - also used in external ssh segment
function ip_address {
    local address
    local ip_loc
    local ifconfig_loc

    # check if the ip command exists
    if ip_loc="$(type -p "ip")" || [[ -n $ip_loc ]]; then
        # shellcheck disable=SC2005
        address="$(ip route get 1 | tr -s ' ' | cut -d' ' -f7)"
    elif ifconfig_loc="$(type -p "ifconfig")" || [[ -n $ifconfig_loc ]]; then
        while IFS=$': \t' read -ra _line ;do
            [ -z "${_line%inet}"   ] &&
                _ip=${_line[${#_line[1]}>4?1:2]} &&
                [ "${_ip#127.0.0.1}"   ] && address=$_ip
        done< <(LANG=C /sbin/ifconfig)
    else
        address="127.0.0.1"
    fi
    echo "$address"
}

# -----------------------------------------------------------------------------
# append to prompt: current time
# arg: $1 foreground color
# arg: $2 background color
# optional variables;
#   PL_TIME_SHOW_SECONDS: true/false for hh:mm:ss / hh:mm
function time_segment {
    local bg_color="$1"
    local fg_color="$2"
    local content
    content="$(pl_symbol 'time')"
    if $PL_TIME_SHOW_SECONDS ; then
        content+="\t"
    else
        content+="\A"
    fi
    PS1+="$(segment_end "$fg_color" "$bg_color")"
    PS1+="$(segment_content "$fg_color" "$bg_color" " $content ")"
    __last_color="$bg_color"
}

#------------------------------------------------------------------------------
# append to prompt: user@host or user or root@host
# arg: $1 foreground color
# arg: $2 background color
# option variables;
#   PL_USER_SHOW_HOST: true/false to show host name/ip
#   PL_USER_USE_IP: true/false to show IP instead of hostname
function user_segment {
    local bg_color="$1"
    local fg_color="$2"
    local content
    content="$(pl_symbol 'user')\u"
    # Show host if true or when user is remote/root
    if $PL_USER_SHOW_HOST ; then
        if $PL_USER_USE_IP ; then
            content+="@$(ip_address)"
        else
            content+="@\h"
        fi
    fi
    PS1+="$(segment_end "$fg_color" "$bg_color")"
    PS1+="$(segment_content "$fg_color" "$bg_color" " $content ")"
    __last_color="$bg_color"
}

# -----------------------------------------------------------------------------
# append to prompt: current directory
# arg: $1 foreground color
# arg; $2 background color
# option variables;
#   PL_PATH_TRIM: 0—fullpath, 1—current dir, [x]—trim to x number of dir
function path_segment {
    local bg_color="$1"
    local fg_color="$2"
    local content="\w"
    if [[ $PL_PATH_TRIM -eq 1 ]]; then
        content="\W"
    elif [[ $PL_PATH_TRIM -gt 1 ]]; then
        PROMPT_DIRTRIM="$PL_PATH_TRIM"
    fi
    PS1+="$(segment_end "$fg_color" "$bg_color")"
    PS1+="$(segment_content "$fg_color" "$bg_color" " $content ")"
    __last_color="$bg_color"
}

# -----------------------------------------------------------------------------
# append to prompt: the number of background jobs running
# arg: $1 foreground color
# arg; $2 background color
function background_jobs_segment {
    local bg_color="$1"
    local fg_color="$2"
    local number_jobs
    number_jobs=$(jobs | grep -cv "Done" | tr -d '[:space:]')
    if [[ $number_jobs -ne 0 ]]; then
        PS1+="$(segment_end "$fg_color" "$bg_color")"
        PS1+="$(segment_content "$fg_color" "$bg_color" " $(pl_symbol "background_jobs") $number_jobs ")"
        __last_color="$bg_color"
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: indicator is the current directory is ready-only
# arg: $1 foreground color
# arg; $2 background color
function read_only_segment {
    local bg_color="$1"
    local fg_color="$2"
    if [[ ! -w $PWD ]]; then    # file exists and is (!not) writeable
        PS1+="$(segment_end "$fg_color" "$bg_color")"
        PS1+="$(segment_content "$fg_color" "$bg_color" " $(pl_symbol "read_only") ")"
        __last_color="$bg_color"
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: append a '$' prompt with optional return code for previous command
# arg: $1 foreground color
# arg; $2 background color
function prompt_segment {
    local bg_color="$1"
    local fg_color="$2"
    local content
    if [[ ${EUID} -eq 0 ]]; then
        if [[ -n $PL_PROMPT_ROOT_FG ]]; then
            fg_color="$PL_PROMPT_ROOT_FG"
        fi
        if [[ -n $PL_PROMPT_ROOT_BG ]]; then
            bg_color="$PL_PROMPT_ROOT_BG"
        fi
    fi
    PS1+="$(segment_end "$fg_color" "$bg_color")"
    PS1+="$(segment_content "$fg_color" "$bg_color" " $PL_PROMPT_CHAR ")"
    __last_color="$bg_color"
}

# -----------------------------------------------------------------------------
# append to prompt: append a '$' prompt with optional return code for previous command
# arg: $1 foreground color
# arg; $2 background color
function return_code_segment {
    if [[ $__return_code -ne 0 ]]; then
        local bg_color="$1"
        local fg_color="$2"
        local content
        content=" $(pl_symbol 'return_code') $__return_code "
        PS1+="$(segment_end "$fg_color" "$bg_color")"
        PS1+="$(segment_content "$fg_color" "$bg_color" "$content")"
        __last_color="$bg_color"
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: end the current promptline and start a newline
function newline_segment {
    if [[ -n $__last_color ]]; then
        PS1+="$(segment_end "$__last_color" 'bg_default')"
    fi
    PS1+="\n"
    unset __last_color
}

# -----------------------------------------------------------------------------
# code to run before processing $PROMT_COMMAND
function pureline_pre {
    __return_code=$? # save return code of last command
    [[ $PL_SET_TITLEBAR == true ]] && echo -ne "\e]2;${PL_TITLEBAR@P}\a"  # set the gui window title
}

# -----------------------------------------------------------------------------
function pureline_ps1 {
    PS1=""                                  # reset the command prompt

    # load the segments
    local segment_index
    for segment_index in "${!PL_SEGMENTS[@]}"; do
        ${PL_SEGMENTS[$segment_index]};
    done

    # final end point
    if [[ -n $__last_color ]]; then
        PS1+="$(segment_end "$__last_color" 'bg_default') "
    else
        # No segments loaded, set a basic prompt
        PS1="No PureLine Segments: $PL_PROMPT_CHAR"
    fi

    # cleanup
    PS1+="\[\e[0m\]"            # color off
    if $PL_ERASE_TO_EOL ; then
        PS1+="\[\e[K\]"         # clear to end of line
    fi
    unset __last_color
    unset __return_code
}

# -----------------------------------------------------------------------------
# define the basic color set
function set_default_colors() {
    PL_COLORS=(
        # copy paste from xresources color theme.
        # duplicated here for convenience when running PureLine without
        # supporting files.
        [0]='0'     # black
        [1]='5'     # magenta
        [2]='8'     # bold black
        [3]='7'     # silver
        [4]='6'     # cyan
        [5]='14'    # bold cyan
        [6]='11'    # yellow
        [7]='15'    # white
        [8]='9'     # red
        [9]='1'     # br red
        [10]='3'    # yellow
        [12]='2'    # green
        [11]='10'   # bold green
        [14]='4'    # blue
        [13]='12'   # bold blue
        [15]='13'   # bold magenta
    )
}

# -----------------------------------------------------------------------------
# default symbols are intended for 'out-ofthe-box' compatibility.
# symbols from code page 437: character set of the original IBM PC
function set_default_symbols {
    PL_STYLE='classic'

    PL_SYMBOLS+=(
        [classic_hard_separator]=''
        [classic_soft_separator]=''

        [reslash_hard_separator]='◤'
        [reslash_soft_separator]='╱'

        [slash_hard_separator]='◣'
        [slash_soft_separator]='╲'

        [tty_hard_separator]='▶'
        [tty_soft_separator]='│'

        [tty_read_only]='Θ'
        [read_only]=""

        [tty_return_code]='x'
        [return_code]="⚑"

        [tty_background_jobs]='↔'
        [background_jobs]="⏎"
    )
}

# -----------------------------------------------------------------------------
# default basic set of segments
function set_default_config {
    PL_SEGMENTS=(
        'user_segment        2      7'
        'path_segment        13     7'
        'read_only_segment   15     7'
    )
    PL_USER_SHOW_HOST=true
    PL_PATH_TRIM=2
    # set some defaults
    PL_COLOR=''             # using default color set
    PL_SET_TITLEBAR=false   # by default we don't set titlebar
    PL_TITLEBAR="\u@\h: \w" # title bar can use PS1 style \u etc
    PL_ERASE_TO_EOL=false   # need on some terminals to prevent glitches
}

# -----------------------------------------------------------------------------
# entry point to setup pureline
function main() {
    local segment_index
    local segment_function

    set_default_colors
    set_default_symbols
    set_default_config

    [[ ${EUID} -eq 0 ]] && PL_PROMPT_CHAR='#' || PL_PROMPT_CHAR='$'

    # check if an argument has been given for a config file
    if [[ -f $1 ]]; then
        # shellcheck disable=SC1090
        source "$1"
    fi

    # source external segments
    export PL_DIR
    # PL_DIR=$(dirname "${BASH_SOURCE[0]}")'/segments'
    PL_DIR=$(dirname "${BASH_SOURCE[0]}")''
    for segment_index in "${!PL_SEGMENTS[@]}"; do
        # check if segment function is not defined
        segment_function=${PL_SEGMENTS[$segment_index]%% *}
        if [ -z "$(type -t "$segment_function")" ]; then
            # if not defined, source external function
            # shellcheck disable=SC1090
            source "$PL_DIR"'/segments/'"$segment_function"
        fi
    done
    # shellcheck disable=SC1090
    [[ -n $PL_COLOR ]] && source "$PL_DIR"'/colors/'"$PL_COLOR"

    # dynamically set the  PS1
    # shellcheck disable=SC2015
    if [[ ! ${PROMPT_COMMAND} =~ 'pureline_ps1' ]]; then
        # TODO strip trailing whitespace from PROMPT_COMMAND and check 
        # if last char is a semicolon
        [[ ! ${#PROMPT_COMMAND} -eq 0 ]] && PROMPT_COMMAND+=";"
        PROMPT_COMMAND="pureline_pre; $PROMPT_COMMAND pureline_ps1;"
    fi
}

main "${@}"

