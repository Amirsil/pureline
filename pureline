#!/usr/bin/env bash

# PureLine - A Pure Bash Powerline PS1 Command Prompt 
# This script should be sourced and not executed

# Global variables

declare -A PL_SEPARATORS=() # Hash table to reference symbols
declare -A PL_COLORS=()     # Hash table to reference colors
declare -a PL_SEGMENTS=()   # Array to hold segments and their arguments

PL_PRIMARY_DEFAULT=7        # default primary color
PL_SECONDARY_DEFAULT=0      # default secondary color

# -----------------------------------------------------------------------------
# returns an escaped color code for printing to terminal
# arg: $1 color array index and returns the formatted result by refernce
# arg: $2 true/false is background
function format_color {
    local -n _color=$1
    local isBackground=$2

    if [[ ${_color} == 'default' ]]; then
        [[ ${isBackground} == true ]] && _color='\e[49m' || _color='\e[0;39m'
    else
        local mode fgbg
        [[ ${PL_COLORS[${_color}]} =~ ';' ]] && mode='2' || mode='5'
        [[ ${isBackground} == true ]] && fgbg='48' || fgbg='38'
        _color="\e[${fgbg};${mode};${PL_COLORS[${_color}]}m"
    fi
    _color="\[${_color}\]"  # function return value
}

# -----------------------------------------------------------------------------
# returns a color formatted string with the powerline symbol for a segment end
# arg: $1 is used to return formatted symbol by reference
# arg: $2 is foreground color of the next segment
# arg: $3 is background color of the next segment
function segment_end {
    local -n _end_symbol=$1
    local fg bg=$3

    if [[ ${PL_STYLE} == 'lean' ]]; then
        _end_symbol=''
        return
    fi

    case "${__last_color}" in
        '')     # if no last color, this is the first segment
            _end_symbol=''
            fg="$2"
            ;;
        "$3")   # segment colors are the same, use a foreground separator
            _end_symbol="${PL_SEPARATORS[${PL_STYLE}_'soft']}"
            fg="$2"
            ;;
        *)      # segment colors are different, use a background separator
            _end_symbol="${PL_SEPARATORS[${PL_STYLE}_'hard']}"
            fg="${__last_color}"
    esac
    __last_color="${bg}"

    format_color fg false
    format_color bg true
    _end_symbol="${fg}${bg}${_end_symbol}"  # function return value
}

# -----------------------------------------------------------------------------
# helper function to add a formatted segment to the PS1
# arg: $1 string: content
# arg: $2 int: primary color
# arg: $3 int: secondary color
# arg: $4 boolean: lean style, if true box content with square brackets
function add_segment {
    local content=$1
    local bg="${2:-${PL_PRIMARY_DEFAULT}}"      # set bg to primary color
    local fg="${3:-${PL_SECONDARY_DEFAULT}}"    # set fg to secondary color

    if [[ ${PL_STYLE} == 'lean' ]]; then
        fg="${bg}"  # on lean style, switch primary color to foreground
        bg='default'
        [[ ${4:-true} == true ]] && content="[${content}]" || content=" ${content}"
    else
        local end_symbol
        segment_end end_symbol "${fg}" "${bg}"
        [[ -n ${end_symbol} ]] && PS1+="${end_symbol}"
        content=" ${content} "
    fi

    format_color fg false
    format_color bg true
    PS1+="${fg}${bg}${content}"
}

# -----------------------------------------------------------------------------
# Helper function for User segment - also used in external ssh segment
# arg: $1 return value for result
function ip_address {
    local -n _ip_address=$1

    # check if the ip command exists
    if command -v ip &> /dev/null ; then
        # shellcheck disable=SC2005
        _ip_address="$(ip route get 1 | tr -s ' ' | cut -d' ' -f7)"
    elif command -v ifconfig &> /dev/null ; then
        local _ip
        while IFS=$': \t' read -ra _line ;do
            [[ -z "${_line%inet}" ]] &&
                _ip=${_line[${#_line[1]}>4?1:2]} &&
                [[ ${_ip#127.0.0.1} ]] && _ip_address=${_ip}
        done< <(LANG=C /sbin/ifconfig)
    else
        # shellcheck disable=SC2034
        _ip_address='127.0.0.1'
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: current time
# arg: $1 primary color
# arg: $2 secondary color
# optional variables;
#   PL_TIME_SHOW_SECONDS: true/false for hh:mm:ss / hh:mm
function time_segment {
    local content
    if ${PL_TIME_SHOW_SECONDS:-false:} ; then
        content="\t"
    else
        content="\A"
    fi
    add_segment "${content}" "$1" "$2"
}

#------------------------------------------------------------------------------
# append to prompt: user | user@host | user@127.0.0.1 | user@host(127.0.0.1)
# arg: $1 primary color
# arg: $2 secondary color
# option variables;
# PL_HOST_ENABLE_USER: string - show username   'always'|'never'|'ssh'
# PL_HOST_ENABLE_NAME: string - show hostname   'always'|'never'|'ssh'
# PL_HOST_ENABLE_IP:   string - show ip address 'always'|'never'|'ssh'
# PL_HOST_SPLIT:       boolean - split into segments
function host_segment {
    local is_ssh
    [[ -n ${SSH_CLIENT:-} || -n ${SSH_TTY:-} ]] && is_ssh=true || is_ssh=false

    local user
    if [[ ${PL_HOST_ENABLE_USER} != 'never' ]]; then
        if [[ ${PL_HOST_ENABLE_USER} == 'always' ]] ||
            [[ ${PL_HOST_ENABLE_USER} == 'ssh' && ${is_ssh} == true ]]; then
            user='\u'
        fi
    fi

    local host
    if [[ ${PL_HOST_ENABLE_NAME} != 'never' ]]; then
        if [[ ${PL_HOST_ENABLE_NAME} == 'always' ]] || 
            [[ ${PL_HOST_ENABLE_NAME} == 'ssh' && ${is_ssh} == true ]]; then
            host='\h'
        fi
    fi

    local ip
    if [[ ${PL_HOST_ENABLE_IP} != 'never' ]]; then
        if [[ ${PL_HOST_ENABLE_IP} == 'always' ]] || 
            [[ ${PL_HOST_ENABLE_IP} == 'ssh' && ${is_ssh} == true ]]; then
            ip_address ip
            [[ -n ${host} ]] && host="${host}(${ip})" || host=${ip}
        fi
    fi

    local content
    content+=${user}
    if [[ -n ${user} && -n ${host} ]]; then
        if ${PL_HOST_SPLIT:-false}; then
            content+=" ${PL_SEPARATORS[${PL_STYLE}_'soft']} "
        else
            content+="@"
        fi
    fi
    content+=${host}
    [[ -n ${content} ]] && add_segment "${content}" "$1" "$2"
}

# -----------------------------------------------------------------------------
# append to prompt: current directory
# arg: $1 primary color
# arg: $2 secondary color
# option variables;
#   PL_PATH_TRIM: 0—fullpath, 1—current dir, [x]—trim to x number of dir
function path_segment {
    local content

    if ${PL_PATH_SPLIT:-false}; then
        # split directories into segments

        content="${PWD/#${HOME}/~}" #works for bash < 4.4 #$(pwd)
        content="${content/#${HOME}/\~}" #escaping needed for bash >= 4.4

        if [[ ${PL_PATH_TRIM} -eq 1 ]]; then
            # show only current dir from end of path
            content="${content##*/}"
        elif [[ ${PL_PATH_TRIM} -gt 1 ]]; then
            local re=")$"
            local ree="\/[^\/]*"
            for (( i = 0; i < PL_PATH_TRIM; i++ )); do
                re="${ree}${re}"
            done
            re="(${re}"
            [[ ${content} =~ ${re} ]]
            ret=${BASH_REMATCH[1]}
            [[ ${#ret} -gt 0 ]] && content="${PL_ELLIPSE_SYMBOL}${ret}"
        fi
        local sep="${PL_SEPARATORS[${PL_STYLE}_'soft']}"
        content="${content//\// ${sep} }"
        [[ ${content:0:2} == " ${sep}" ]] && content="/${content}"
        [[ ${content: -2} == "${sep} " ]] && content=${content%%???}
    else
        # show path in single segment
        content="\w"
        if [[ ${PL_PATH_TRIM} -eq 1 ]]; then
            content="\W"
        elif [[ ${PL_PATH_TRIM} -gt 1 ]]; then
            PROMPT_DIRTRIM="${PL_PATH_TRIM}"
        fi
    fi
    add_segment "${content}" "$1" "$2"
}

# -----------------------------------------------------------------------------
# append to prompt: the number of background jobs running
# arg: $1 primary color
# arg: $2 secondary color
function background_jobs_segment {
    local number_jobs=0
    # count the number of jobs, excluding those marked as 'Done'
    while read -r line ; do
        [[ -n ${line} && ! ${line} =~ 'Done' ]] && number_jobs=$((number_jobs+1))
    done <<< "$(jobs)"
    if [[ ${number_jobs} -ne 0 ]]; then
        add_segment "${PL_JOBS_SYMBOL}${number_jobs}" "$1" "$2"
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: indicator is the current directory is ready-only
# arg: $1 primary color
# arg: $2 secondary color
function read_only_segment {
    [[ -w ${PWD} ]] && return   # if current directory is writeable, do nothing

    add_segment "${PL_RO_SYMBOL}" "$1" "$2"
}

# -----------------------------------------------------------------------------
# append to prompt: default is '$' for normal user and '#' for root
# arg: $1 primary color
# arg: $2 secondary color
# arg: $3 primary hilite
# arg: $4 secondary hilite
function prompt_segment {
    local primary_color="$1"
    local secondary_color="$2"
    local prompt_char=${PL_PROMPT_CHAR:-'$'}

    # if user is root, change the segment colors and prompt
    if [[ ${EUID} -eq 0 ]]; then
        primary_color="${3:-${primary_color}}"
        secondary_color="${4:-${secondary_color}}"
        prompt_char=${PL_PROMPT_CHAR_ROOT:-'#'}
    fi
    add_segment "${prompt_char}" "$primary_color" "$secondary_color" false
}

# -- ---------------------------------------------------------------------------
# append to prompt: show when a command return code is available
# arg: $1 primary color
# arg: $2 secondary color
function return_code_segment {
    # don't show if success (0) or ctrl-c (130)
    [[ ${__return_code} -eq 0 || ${__return_code} -eq 130 ]] && return

    add_segment "${PL_RETURN_CODE_SYMBOL}${__return_code}" "$1" "$2"
    __return_code=0
}

# -----------------------------------------------------------------------------
# append to prompt: end the current promptline and start a newline
function newline_segment {
    if [[ -n ${__last_color} ]]; then
        local end_symbol
        segment_end end_symbol "${__last_color}" 'default'
        PS1+="${end_symbol}"
        if ${PL_ERASE_TO_EOL} ; then
            PS1+="\[\e[K\]"         # clear to end of line
        fi
    fi
    PS1+="\n"
    unset __last_color
}

# -----------------------------------------------------------------------------
# code to run before processing $PROMT_COMMAND
function pureline_pre {
    __return_code=$? # save return code of last command
    # [[ ${PL_SET_TITLEBAR} == true ]] && echo -ne "\e]2;${PL_TITLEBAR@P}\a"  # set the gui window title
    if ${PL_SET_TITLEBAR:-false}; then
        if (( ${BASH_VERSINFO[0]:-0} > 4 ||
            (${BASH_VERSINFO[0]:-0} == 4 &&
            ${BASH_VERSINFO[1]:-0} >= 4) )); then
            echo -ne "\e]2;${PL_TITLEBAR@P}\a"  # set the gui window title
        else
            echo -ne "\e]2;'${PL_TITLEBAR}'\a"  # set the gui window title
        fi
    fi
}

# -----------------------------------------------------------------------------
function pureline_ps1 {
    PS1=""                                  # reset the command prompt

    # load the segments
    local idx
    for idx in "${!PL_SEGMENTS[@]}"; do
        ${PL_SEGMENTS[${idx}]};
    done

    # final end point
    if [[ -n ${PS1} ]]; then
        local end_symbol
        segment_end end_symbol "${__last_color}" 'default'
        PS1+="${end_symbol} "
    else
        # No segments loaded, set a basic prompt
        PS1="No PureLine Segments: ${PL_PROMPT_CHAR}"
    fi

    # cleanup
    PS1+="\[\e[0m\]"            # color off
    if ${PL_ERASE_TO_EOL} ; then
        PS1+="\[\e[K\]"         # clear to end of line
    fi
    unset __last_color
    unset __return_code
}

# -----------------------------------------------------------------------------
# define the basic color set
function set_default_colors() {
    PL_COLORS=(
        # copy paste from xresources color theme.
        # duplicated here for convenience when running PureLine without
        # supporting files.
        [0]='0'     # black
        [1]='5'     # magenta
        [2]='8'     # bold black
        [3]='7'     # silver
        [4]='6'     # cyan
        [5]='14'    # bold cyan
        [6]='11'    # yellow
        [7]='15'    # white
        [8]='9'     # red
        [9]='1'     # br red
        [10]='3'    # yellow
        [12]='2'    # green
        [11]='10'   # bold green
        [14]='4'    # blue
        [13]='12'   # bold blue
        [15]='13'   # bold magenta
    )
}

# -----------------------------------------------------------------------------
# basic symbols for segment separators and builtins
function set_default_symbols {
    PL_SEPARATORS=(
        [slash_hard]='◣'
        [slash_soft]='╲'

        [reslash_hard]='◤'
        [reslash_soft]='╱'

        [classic_hard]=''      # e0b0
        [classic_soft]=''      # e0b1

        [reslashy_hard]=''     # e0bc
        [reslashy_soft]=''     # e0bd

        [slashy_hard]=''       # e0b8
        [slashy_soft]=''       # e0b9
    )
    PL_ELLIPSE_SYMBOL=''       # '…'
    PL_JOBS_SYMBOL='⏎ '
    PL_RO_SYMBOL=''
    PL_RETURN_CODE_SYMBOL='⚑ '
}

# -----------------------------------------------------------------------------
# default basic set of segments
function set_default_config {
    # set some defaults
    PL_STYLE='lean'         # use the classic powerline symbols
    PL_COLOR=''             # using default color set
    PL_SET_TITLEBAR=false   # by default we don't set titlebar
    PL_TITLEBAR="\u@\h: \w" # title bar can use PS1 style \u etc
    PL_ERASE_TO_EOL=false   # need on some terminals to prevent glitches
    # enable some segments
    PL_SEGMENTS=(
        'host_segment        2      7'
        'path_segment        13     7'
        'read_only_segment   15     7'
        'prompt_segment      2      7'
    )
    # segment options
    PL_HOST_ENABLE_USER='ssh'   # options always|never|ssh
    PL_HOST_ENABLE_NAME='ssh'   # options always|never|ssh
    PL_HOST_ENABLE_IP='never'   # options always|never|ssh    
    PL_PATH_SPLIT=false         # single segment path Vs segment per directory
    PL_PATH_TRIM=2              # 0-fullpath,1-current dir,[n]-trim to n directories
}

# -----------------------------------------------------------------------------
# entry point to setup pureline
function main() {
    local idx
    local segment_function

    set_default_colors
    set_default_symbols
    set_default_config

    # check if an argument has been given for a config file
    # shellcheck disable=SC1090
    [[ -f $1 ]] && source "$1"

    # source external segments
    export PL_DIR
    PL_DIR=${PL_DIR:-$(dirname "${BASH_SOURCE[0]}")''}
    for idx in "${!PL_SEGMENTS[@]}"; do
        segment_function=${PL_SEGMENTS[${idx}]%% *}
        # if external segment exists, source it
        if [[ -f "${PL_DIR}"'/segments/'"${segment_function}" ]]; then
            # if not defined, source external function
            # shellcheck disable=SC1090
            source "${PL_DIR}"'/segments/'"${segment_function}"
        else
            # if not external, check if already defined internal
            if [[ -z "$(type -t "${segment_function}")" ]]; then
                printf "Segment not found: %s\n" "${segment_function}"
                PL_SEGMENTS[${idx}]=''
            fi
        fi
    done
    # shellcheck disable=SC1090
    [[ -n ${PL_COLOR} ]] && source "${PL_DIR}"'/colors/'"${PL_COLOR}"

    # dynamically set the  PS1
    if [[ ! ${PROMPT_COMMAND} =~ 'pureline_ps1' ]]; then
        # TODO strip trailing whitespace from PROMPT_COMMAND and check 
        # if last char is a semicolon
        [[ ! ${#PROMPT_COMMAND} -eq 0 ]] && PROMPT_COMMAND+=";"
        PROMPT_COMMAND="pureline_pre; ${PROMPT_COMMAND} pureline_ps1;"
    fi
}

main "${@}"

