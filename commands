#!/usr/bin/env bash

# PureLinePrompt Commands

# -----------------------------------------------------------------------------
# usage
function _usage() {
cat << EOF
usage: plp [command] [arg]

PureLinePrompt commands:
  set
    option          set a config option
    style           set a style for the current prompt
    theme           set a color theme for the current prompt
 list
    colors          list the colors in the current theme
    options         list the config options
    segments        list enabled segments all|enabled
        all         list all available segments
        enabled     list only enabled segments
    styles          list available styles
    themes          list available color themes
  reload            reload settings from config 

Example usage:
  plp set option path_split false
  plp set style classic
  plp set theme xresources
EOF
}

# -----------------------------------------------------------------------------
# List the colors in the current set
function _list_colors {
    local idx color mode
    
    [[ -z ${PL_COLORS:-} ]] && return 

    for idx in {0..15}; do
        color=${PL_COLORS[${idx}]}
        [[ ${color} =~ ';' ]] &&
            mode='2' ||
            mode='5'
        [[ ${color} != bg_default ]] &&
            color="48;${mode};${PL_COLORS[${idx}]}m" ||
            color='49m\]'
        printf "\e[38;${mode};0m\e[${color} COLOR: %2d %17s \e[49m\e[0m\n" "${idx}" "${color}"
    done
}

# -----------------------------------------------------------------------------
function _list_options() {
    for key in "${!PL_OPTIONS[@]}"; do
        printf "%s='%s'\n" "${key}" "${PL_OPTIONS[${key}]}"
    done | sort
}

# -----------------------------------------------------------------------------
function _list_themes() {
    [[ -z ${PL_DIR:-} ]] && return
    for theme in "${PL_DIR}"/colors/*; do
        printf "%s\n" "${theme##*/}"
    done
}

# -----------------------------------------------------------------------------
function _list_segments() {
    [[ -z ${PL_DIR:-} ]] && return
    local enabled
    local segment
    for segment in "${PL_DIR}"/segments/*; do
        segment="${segment##*/}"
        segment="${segment%_*}"
        [[ ${PL_SEGMENTS[*]} =~ ${segment} ]] && enabled=true || enabled=false
        [[ ${enabled} == true && ${1} == 'all' ]] &&
            segment+=" (*)"
        [[ ${1} == 'all' || ${enabled} == true ]] &&
            printf "%s\n" "${segment}"
    done
}

# -----------------------------------------------------------------------------
function _list_styles() {
    [[ -z ${PL_STYLES:-} ]] && return
    for style in "${PL_STYLES[@]}"; do
        printf "%s\n" "${style}"
    done
}

# -----------------------------------------------------------------------------
function _set_option() {
    PL_OPTIONS[${1}]="${2}"
}

# -----------------------------------------------------------------------------
function _set_style() {
    PL_OPTIONS[style]="${1}"
}

# -----------------------------------------------------------------------------
# shellcheck disable=SC1090
function _set_theme() {
    source "${PL_DIR}/colors/${1}"
}

# -----------------------------------------------------------------------------
function _error() {
    [[ -n $1 ]] &&
        printf "plp: '%s' is not a PureLine Prompt command.\n\n" "${1}"
    _usage
}
# -----------------------------------------------------------------------------
# PureLinePrompt commands
function plp {
    case "${1}" in
        'list')
            case "${2}" in
                'colors')
                    _list_colors
                    ;;
                'options')
                    _list_options
                    ;;
                'segments')
                    _list_segments "${3}"
                    ;;
                'styles')
                    _list_styles
                    ;;
                'themes')
                    _list_themes
                    ;;
                *)
                    _error "${2}"
            esac
            ;;
        'set')
            case "${2}" in
                'option')
                    _set_option "${3}" "${4}"
                    ;;
                'style')
                    _set_style "${3}"
                    ;;
                'theme')
                    _set_theme "${3}"
                    ;;
                *)
                    _error "${2}"
            esac
            ;;
        'reload')
            _plp_init
            ;;
        *)
            _error "${1}"
    esac
}

# -----------------------------------------------------------------------------
# plp command line completions
_plp_completions() {
    local completions=()
    case ${COMP_WORDS[1]} in
        'reload')
            completions=()
            ;;
        'set')
            case ${COMP_WORDS[2]} in
                'option')
                    [[ ${COMP_CWORD} == 3 ]] &&
                        for key in "${!PL_OPTIONS[@]}"; do
                            completions+=( "${key}" )
                        done
                    ;;
                'style')
                    [[ ${COMP_CWORD} == 3 ]] &&
                        for style in "${PL_STYLES[@]}"; do
                            completions+=( "${style}" )
                        done
                    ;;
                'theme')
                    [[ ${COMP_CWORD} == 3 ]] &&
                        for theme in "${PL_DIR}"/colors/*; do
                            completions+=( "${theme##*/}" )
                        done
                    ;;
                *)
                    [[ ${COMP_CWORD} == 2 ]] && completions=( 'option' 'theme' 'style' )
            esac
            ;;
        'list')
            case ${COMP_WORDS[2]} in
                'segments')
                    [[ ${COMP_CWORD} == 3 ]] &&
                        completions+=( 'all' 'enabled' )
                    ;;
                *)
                    [[ ${COMP_CWORD} == 2 ]] &&
                        completions=( 'colors' 'options' 'segments' 'styles' 'themes' )
            esac
            ;;
        *)
            completions=( 'reload' 'set' 'list')
    esac

    mapfile -t COMPREPLY < <(
        compgen -W "${completions[*]}" "${COMP_WORDS[COMP_CWORD]}"
    )
}

complete -F _plp_completions plp
